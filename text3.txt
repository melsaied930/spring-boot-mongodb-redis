I have this code in my project
Can I reorganize and better cleaner?
---------------------------------------------------------------------------------------------------------------
package com.example.spring_boot_mongodb_redis.config;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;
@Configuration
@ConfigurationProperties(prefix = "app")
@Data
public class AppConfig {
    private String apiUrl;
    private String userDataFile;
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
---------------------------------------------------------------------------------------------------------------
package com.example.spring_boot_mongodb_redis.config;

import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.BasicPolymorphicTypeValidator;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;

import java.time.Duration;

@Configuration
@EnableCaching
@ConditionalOnProperty(name = "cache.enabled", havingValue = "true", matchIfMissing = true)
public class RedisCacheConfig {

    @Value("${spring.cache.redis.time-to-live:600}")
    private long ttlSeconds;

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        // Enable default typing to allow polymorphic deserialization
        objectMapper.activateDefaultTyping(
                BasicPolymorphicTypeValidator.builder().allowIfBaseType(Object.class).build(),
                ObjectMapper.DefaultTyping.NON_FINAL,
                JsonTypeInfo.As.PROPERTY
        );
        GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(objectMapper);
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(ttlSeconds))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(serializer));

        return RedisCacheManager
                .builder(redisConnectionFactory)
                .cacheDefaults(config)
                .build();
    }
}
---------------------------------------------------------------------------------------------------------------
// RedisCustomConfig.java
package com.example.spring_boot_mongodb_redis.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisPassword;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;

@Configuration
public class RedisCustomConfig {

    @Value("${spring.data.redis.host}")
    private String redisHost;

    @Value("${spring.data.redis.port}")
    private int redisPort;

    @Value("${spring.data.redis.password}")
    private String redisPassword;

    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration(redisHost, redisPort);
        config.setPassword(RedisPassword.of(redisPassword));
        return new LettuceConnectionFactory(config);
    }
}
---------------------------------------------------------------------------------------------------------------
package com.example.spring_boot_mongodb_redis.config;

import com.example.spring_boot_mongodb_redis.model.DatabaseSequence;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.data.mongodb.core.FindAndModifyOptions;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.stereotype.Service;

@Slf4j
@Service
public class SequenceGeneratorService {

    private final MongoOperations mongoOperations;

    @Autowired
    public SequenceGeneratorService(MongoOperations mongoOperations) {
        this.mongoOperations = mongoOperations;
    }

    public long generateSequence(String seqName) {
        try {
            mongoOperations.insert(new DatabaseSequence(seqName, 100L));
            log.debug("Initialized sequence '{}' to 100", seqName);
        } catch (DuplicateKeyException ignored) {
            log.debug("Sequence '{}' already initialized, skipping seed", seqName);
        }

        DatabaseSequence counter = mongoOperations.findAndModify(
                Query.query(Criteria.where("_id").is(seqName)),
                new Update().inc("seq", 1),
                FindAndModifyOptions.options().returnNew(true),
                DatabaseSequence.class
        );

        if (counter == null) {
            log.warn("Counter for '{}' was null after upsert+inc; inserting fallback value 101", seqName);
            mongoOperations.insert(new DatabaseSequence(seqName, 101L));
            return 101L;
        }
        return counter.getSeq();
    }
}
---------------------------------------------------------------------------------------------------------------
package com.example.spring_boot_mongodb_redis.interceptor;

import com.example.spring_boot_mongodb_redis.service.CacheMetrics;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.interceptor.CacheInterceptor;
import org.springframework.cache.interceptor.CacheOperationInvoker;
import org.springframework.cache.interceptor.CacheOperationSource;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Component
@Primary
public class MetricsRecordingCacheInterceptor extends CacheInterceptor {

    private static final Logger redisLogger = LoggerFactory.getLogger("RedisTransactions");
    private final CacheMetrics metricsCollector;

    public MetricsRecordingCacheInterceptor(CacheMetrics metricsCollector, CacheOperationSource cacheOperationSource) {
        this.metricsCollector = metricsCollector;
        setCacheOperationSource(cacheOperationSource);
    }

    @Override
    protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) {
        String className = target.getClass().getSimpleName();
        String methodName = method.getName();

        redisLogger.debug("Cache interceptor executing: {}.{}", className, methodName);

        long startTime = System.currentTimeMillis();
        Object result = super.execute(invoker, target, method, args);
        long endTime = System.currentTimeMillis();

        // Try to determine if this was a cache hit or miss
        // This is a simplification - in reality, it's more complex to determine if a cache hit occurred
        if (result != null) {
            // Assume cache hit for simplicity
            metricsCollector.recordCacheHit("users");
            redisLogger.debug("Cache operation on {}.{} completed in {} ms (likely HIT)",
                    className, methodName, (endTime - startTime));
        } else {
            // Assume cache miss
            metricsCollector.recordCacheMiss("users");
            redisLogger.debug("Cache operation on {}.{} completed in {} ms (likely MISS)",
                    className, methodName, (endTime - startTime));
        }

        return result;
    }

    @Override
    public void afterPropertiesSet() {
        super.afterPropertiesSet();
        redisLogger.info("MetricsRecordingCacheInterceptor initialized");
    }
}
---------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------
package com.example.spring_boot_mongodb_redis.service;

import com.example.spring_boot_mongodb_redis.config.SequenceGeneratorService;
import com.example.spring_boot_mongodb_redis.model.User;
import com.example.spring_boot_mongodb_redis.repository.UserRepository;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.cache.annotation.Caching;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;

@Service
public class UserService {

    private final UserRepository repository;
    private final SequenceGeneratorService sequenceGenerator;

    public UserService(UserRepository repository, SequenceGeneratorService sequenceGenerator) {
        this.repository = repository;
        this.sequenceGenerator = sequenceGenerator;
    }

    @Cacheable(value = "all_users", key = "'getAllUsers'")
    public List<User> getAll() {
        return repository.findAll();
    }

    @Cacheable(value = "users", key = "#id", unless = "#result == null")
    public User getById(Long id) {
        return repository.findById(id)
                .orElseThrow(() -> {
                    String message = "User not found with ID: " + id;
                    return new ResponseStatusException(HttpStatus.NOT_FOUND, message);
                });
    }

    @CachePut(value = "users", key = "#result.id")
    @CacheEvict(value = "all_users", allEntries = true)
    public User create(User user) {
        user.setId(sequenceGenerator.generateSequence("user_sequence"));
        return repository.save(user);
    }

    @CachePut(value = "users", key = "#id")
    @CacheEvict(value = "all_users", allEntries = true)
    public User update(Long id, User userDetails) {
        User user = repository.findById(id)
                .orElseThrow(() -> {
                    String message = "User not found with ID: " + id;
                    return new ResponseStatusException(HttpStatus.NOT_FOUND, message);
                });

        user.setFirstName(userDetails.getFirstName());
        user.setLastName(userDetails.getLastName());
        user.setMaidenName(userDetails.getMaidenName());
        user.setGender(userDetails.getGender());
        user.setEmail(userDetails.getEmail());
        user.setPhone(userDetails.getPhone());
        user.setUsername(userDetails.getUsername());
        user.setPassword(userDetails.getPassword());
        user.setBirthDate(userDetails.getBirthDate());

        return repository.save(user);
    }

    @Caching(evict = {
            @CacheEvict(value = "users", key = "#id"),
            @CacheEvict(value = "all_users", allEntries = true)
    })
    public void delete(Long id) {
        if (repository.existsById(id)) {
            repository.deleteById(id);
        } else {
            String message = "User not found with ID: " + id;
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, message);
        }
    }

}
---------------------------------------------------------------------------------------------------------------
